# 非连续分配管理内存

内存分为大小相等的分区：页框frame,页框号，页帧号，物理块/页号，内存块号

OS把进程分为与页框大小相等的若干份

进程的页面与内存的页框一一对应

页表，记录进程页面号对应内存的页框号

| Process01页面号 | 内存中页框号 |
| --------------- | ------------ |
| 0               | 15987        |
| 1               | 78945        |
| 2               | 65412        |

# 页表数据结构:arrow_up:

例题：物理内存4GB，页面大小4KB，页表项至少多大？

3 Bytes

页表项连续存放，知道页表存放的起始地址，页号不占空间

:star:页表存放的只是内存块号，每号内存块实际物理地址=页框大小*页框号

当进程访问内存时，逻辑地址到物理地址转化：

1. 给定要访问的逻辑地址
2. 确定页面号和偏移量
3. 根据页表，页面号-内存块号，该内存块的起始地址+页内偏移量即为要访问的物理地址

确定某逻辑地址的页号，页内偏移量，逻辑地址x，页帧y，进程共z

x/y页号

x%y页内偏移量

# 设置页面大小为2的整数幂

一般设置页面大小设置为2的整数幂

若计算机使用32位表示逻辑地址，若页面大小为2的x次方，给定某逻辑地址，低位12位表示页内偏移量，剩余20位表示页面号

内存中每内存块的起始物理地址前32-x位为内存块号转化为二进制，后边x位都为0

页面大小=页内偏移量

# :star:基本地址变换机构

<font color =red>页表寄存器(PTR)</font>：存放页表在内存中起始地址和页表长度

进程的PCB进内存的系统区

某进程资源进内存，cpu调用资源，内存保护，地址变换机构检查cpu访问的页框号是否越界（和页表长度对比），若正常，则通过存放在寄存器中的页表起始地址+页号*页表项大小找到该页表项的实际物理地址，找到内存块号，结合页内偏移量，最终在内存中找到实际物理地址

例题：逻辑地址A

A/L页面号->和寄存器内页表长度对比，（页号等于页表长度也中断  ）未越界->根据寄存器内页表起始地址+页面号*页表项大小->找到此页面号的实际物理地址->内存块号->根据内存起始物理地址页内偏移量找到实际物理地址

00000000010000000000-1000005000

注意内存块起始物理地址，块号*页面大小

页表项大小设置为可被页框正好放下的大小，便于查询

总共有2次访问内存，第一次访问找到页表项位置，第二次访问实际需要访问的物理地址