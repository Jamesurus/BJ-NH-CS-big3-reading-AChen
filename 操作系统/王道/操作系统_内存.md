# 内存基础:bear:

## 内存地址、存储单元:kiss:

逻辑地址->物理地址

8GB+256GB 内存+外存

程序执行前，只有数据放入内存，cpu才可执行

内存为何产生？

<font color = red>高速CPU与外存低速I/O操作不匹配，缓和CPU与硬盘IO的速度矛盾</font>

内存每个存储单元可存多少数据：

- 按字节编址：一般1Byte
- 按字编址：16bit或者32bit

G数量单位

B容量单位

2的10次方-1K

2的20次方-1M

2的30次方-1G

## 指令工作原理:pager:

一串二进制码代表一种操作、数据等（计组）

程序编译->机器指令

物理地址，绝对地址

| 0(逻辑地址)-100(物理地址) |
| ------------------------- |
| 1-101                     |
| 2-102                     |
| 3-103                     |
| 4-104                     |

## 3种程序装入内存方式：逻辑->物理地址:man_artist:

<font color = green>绝对装入</font>，灵活性很低，不同主机空闲内存地址不同，无法迁移，编译时，产生绝对地址；单道程序阶段

<font color = green>静态重定位/可重定位装入</font>，逻辑地址+物理地址，在程序装入内存时进行，要求：在一个作业装入内存时，必须分配其要求的全部内存空间，且连续

<font color = green>动态重定位/动态运行时装入</font>，在程序真正执行时，程序内的逻辑地址+动态<font color = red>重定位寄存器</font>内的地址，程序可在内存中移动

编译->机器语言

写程序->程序运行

源代码->目标模块(链接)->装入模块(可执行文件)->装入内存（确定了进程的实际物理地址）

## 3种链接方式：:books:

静态链接：

所有目标模块链接为装入模块，不再拆开，确定了完整的逻辑地址

装入时动态链接:

放入内存时，再进行链接，完整的逻辑地址一边装入，一边形成

运行时动态链接：先将某模块放入内存，需要其他模块时再进行链接，提升对内存的利用率

# 存储结构:feet:

<font color = red>main</font>

storage structure

registers, smallest,以位bit为单位存取数据

Cache比寄存器慢

RAM主存

磁盘-辅助存储设备

register->cache-><font color = red>main</font> memory->disk

主存很小，所以需要磁盘

volatile, 断电内容消失

nonvolatile，断电内容仍在

# 内存管理:wave:

内存空间的分配与回收

逻辑上，对内存空间扩充，物理小内存->逻辑大内存

程序员代码关注逻辑地址，操作系统来实现逻辑地址->物理地址

## 2种内存保护方法：:smile_cat:

各进程间不可互相访问其他的内存空间，互相捣乱，系统不稳定

只可访问自己进程的内存空间，不可访问操作系统及其他进程的内存空间

1. cpu中设置一对上、下限寄存器，cpu要访问某地址时，通过上下界寄存器检查是否越界
2. 重定位寄存器(基址寄存器)：起始<font color=red>物理地址</font>和界地址寄存器(<font color = red>限长寄存器</font>)：最大逻辑地址

感觉本质上大同小异啊bro，buddy！哈哈哈！buddy！

# 覆盖和交换

覆盖： 对用户不透明，增加了用户的编程负担？

在同一个进程或程序中进行

程序分段，常用的常驻内存，

内存：固定区+覆盖区

让不可能同时被访问的程序段共享一个覆盖区

交换：

在不同进程中进行

系统将内存中某些进程暂时换出外存，外存中具备运行条件的进程换入内存，pcb常驻内存（包含在磁盘中的存放地址）

暂时换出外存等待：挂起（suspend）就绪挂起，阻塞挂起

磁盘（外存）：文件区+对换区（占很小部分，I/O速度快）

在对换区，文件采用连续分配方式

内存吃紧，进行交换，当许多进程发生缺页

- 优先换出在内存中处于阻塞态的进程，
- 优先级比较低的进程
- +考虑进程在内存中的驻留时间

# 内存空间的连续分配管理方式

是否是离散的内存空间

## 单一连续分配

内存：系统区+用户区；

内存中只能有一道用户程序

不一定需要采取内存保护

有内部碎片（分配给某进程的内存区域没用完），无外部碎片

## 固定分区分配

内存用户区分为多个固定大小的分区：

分区大小相等/不等

这两种相比，固定分区大小不等的策略稍微好

但是，内存固定分区大小相等适用于一台计算机控制多个相同对象的场合

操作系统建立一数据结构：分区说明表：包含

1. 分区大小，
2. 地址区间，
3. 此分区是否被占用

无外部碎片，有内部碎片

内存中某些<font color=red>空闲分区太小</font>而难以利用

## 动态分区分配

进程在装入内存时，动态申请内存空间

内存回收？

记录内存使用情况的数据结构：

1. 空闲分区表（表项动态删除+增加+内容变化）
2. 空闲分区链

多个空闲分区满足需求，应该选择哪个分区分配？

动态分区分配算法（后边讲）

要将连续空闲内存空间合体

compaction-<font color=red>紧凑技术</font>-移位，

在“紧凑”操作过后，在每进程PCB中修改信息，在内存中的起始位置等

# 动态分区分配算法：

首次、最佳/坏、临近适应算法

## 首次适应算法：

按地址查找，找到可用内存空间即装入进程

空闲分区表/链，按照地址从低到高排列起来

## 临近适应算法(首次适应算法改良版)

因为首次适应算法，可能会导致低地址有很多小外部碎片

地址递增（循环链表）

首次适应算法（能用就行  ）开小，不需对链表重新排列

但是此算法，当低地址地方有小分区恰好可以装下申请的进程，那就浪费了

总结：首次适应算法效果比较好

## 最佳适应算法：

尽可能留下大片空闲内存，空闲分区表/链按照空闲内存大小从小到大排列，<font color=red>利用最小的</font>可利用的内存空间

留下越来越多的外部碎片

## 最坏适应算法：

<font color=red>优先使用大的</font>可用空闲内存空间，

空闲分区表/链按照容量递减的次序排列

导致大块分区被迅速用完，此时来一个大进程，没内存可用



